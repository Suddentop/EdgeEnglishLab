# 패키지#02, #03 유형#11 페이지(단) 분할 로직

## 📋 개요

패키지#02와 패키지#03은 A4 가로 페이지에 2단 레이아웃으로 문제를 출력합니다. 유형#11(본문 문장별 해석)의 경우 문장 수가 많을 때 자동으로 단별 분할이 이루어지며, 문장 번호는 전역적으로 연속성을 유지합니다.

### 패키지별 차이점

- **패키지#02**: 높이 기반 동적 분할 (문장 길이에 따라 자동 계산)
- **패키지#03**: 고정 문장 수 분할 (단당 8개 문장)

## 🎯 핵심 개념

### 2단 레이아웃 구조

```
┌─────────────────────────────────────┐
│           📄 1페이지                │
├──────────────────┬──────────────────┤
│   1번 단 (좌측)   │   2번 단 (우측)   │
│   유형#01        │   유형#07        │
└──────────────────┴──────────────────┘

┌─────────────────────────────────────┐
│           📄 2페이지                │
├──────────────────┬──────────────────┤
│   3번 단 (좌측)   │   4번 단 (우측)   │
│ 유형#11 (1~8)    │ 유형#11 (9~12)   │
└──────────────────┴──────────────────┘

┌─────────────────────────────────────┐
│           📄 3페이지                │
├──────────────────┬──────────────────┤
│   5번 단 (좌측)   │   6번 단 (우측)   │
│   유형#02        │   유형#13        │
└──────────────────┴──────────────────┘
```

## 🔧 구현 로직

### 1. 패키지#02: 높이 기반 동적 분할

**설정 값**
```typescript
const COLUMN_CONFIG = {
  HEIGHT: 21, // A4 가로 페이지 세로 길이 (cm)
  HEADER_HEIGHT: 1.2, // 헤더 높이 (cm)
  CONTENT_PADDING: 0.5, // 콘텐츠 상하 패딩 (cm)
  TITLE_HEIGHT: 1.0, // 문제 제목 높이 (cm)
  INSTRUCTION_HEIGHT: 0.8, // 지시문 높이 (cm)
  SENTENCE_FONT_SIZE: 0.3, // 8.5pt ≈ 0.3cm
  LINE_HEIGHT: 1.4,
  CHAR_WIDTH: 0.22, // 영어 문자 평균 폭 (cm)
  COLUMN_WIDTH: 14.35, // 단 너비 (cm)
  SENTENCE_MARGIN: 0.25, // 문장 간 마진 (cm)
  SENTENCE_PADDING: 0.3, // 문장 패딩 (cm)
};
```

**사용 가능한 단 높이 계산**
```typescript
const getAvailableColumnHeight = () => {
  return COLUMN_CONFIG.HEIGHT 
    - COLUMN_CONFIG.HEADER_HEIGHT 
    - COLUMN_CONFIG.CONTENT_PADDING * 2
    - COLUMN_CONFIG.TITLE_HEIGHT
    - COLUMN_CONFIG.INSTRUCTION_HEIGHT;
};
// 결과: 약 17.5cm
```

**문장 높이 계산**
```typescript
const calculateSentenceHeight = (sentence: string): number => {
  // 한 줄에 들어갈 문자 수 계산
  const charsPerLine = Math.floor(
    (COLUMN_CONFIG.COLUMN_WIDTH - COLUMN_CONFIG.SENTENCE_PADDING * 2) / COLUMN_CONFIG.CHAR_WIDTH
  );
  
  // 필요한 줄 수 계산
  const lines = Math.ceil(sentence.length / charsPerLine);
  
  // 텍스트 높이 + 여백
  const textHeight = lines * COLUMN_CONFIG.SENTENCE_FONT_SIZE * COLUMN_CONFIG.LINE_HEIGHT;
  return textHeight + COLUMN_CONFIG.SENTENCE_MARGIN + COLUMN_CONFIG.SENTENCE_PADDING;
};
```

**높이 기반 문장 분할**
```typescript
const splitWork11SentencesByHeight = (sentences: string[]): string[][] => {
  const result: string[][] = [];
  const availableHeight = getAvailableColumnHeight();
  
  let currentChunk: string[] = [];
  let currentHeight = 0;
  
  for (const sentence of sentences) {
    const sentenceHeight = calculateSentenceHeight(sentence);
    
    // 현재 청크에 추가했을 때 높이가 초과하는지 확인
    if (currentHeight + sentenceHeight > availableHeight && currentChunk.length > 0) {
      // 현재 청크를 결과에 추가하고 새 청크 시작
      result.push([...currentChunk]);
      currentChunk = [sentence];
      currentHeight = sentenceHeight;
    } else {
      // 현재 청크에 추가
      currentChunk.push(sentence);
      currentHeight += sentenceHeight;
    }
  }
  
  // 마지막 청크 추가
  if (currentChunk.length > 0) {
    result.push(currentChunk);
  }
  
  return result;
};
```

**동작 원리:**
- 각 문장의 높이를 실시간으로 계산
- 문장 길이에 따라 줄 수가 달라지므로 높이도 동적으로 변함
- 현재 단의 누적 높이가 사용 가능한 높이를 초과하면 새로운 단으로 분할
- 짧은 문장이 많으면 더 많은 문장을 한 단에 배치 가능
- 긴 문장이 많으면 더 적은 문장을 한 단에 배치

### 2. 패키지#03: 고정 문장 수 분할

```typescript
const splitWork11Sentences = (sentences: string[], maxSentencesPerColumn: number = 8): string[][] => {
  const result: string[][] = [];
  for (let i = 0; i < sentences.length; i += maxSentencesPerColumn) {
    result.push(sentences.slice(i, i + maxSentencesPerColumn));
  }
  return result;
};
```

**동작 원리:**
- 유형#11의 전체 문장 배열을 받아서 단별로 분할
- 기본값: 1단당 최대 8개 문장
- 12개 문장이면 → [1~8], [9~12] 두 개의 청크로 분할
- 문장 길이와 관계없이 항상 8개씩 고정 분할

### 3. 단별 배치 로직 (공통)

```typescript
// 패키지 퀴즈를 단별로 분할
const distributedItems: PackageQuizItem[][] = [];
let currentPageItems: PackageQuizItem[] = [];
let currentColumnIndex = 0; // 현재 단 인덱스 (0: 좌측, 1: 우측)

for (let i = 0; i < packageQuiz.length; i++) {
  const quizItem = packageQuiz[i];
  
  // 유형#11인 경우 문장을 단별로 분할
  if (quizItem.work11Data && quizItem.work11Data.sentences) {
    const sentenceChunks = splitWork11Sentences(quizItem.work11Data.sentences);
    
    sentenceChunks.forEach((chunk, chunkIndex) => {
      const work11Item: PackageQuizItem = {
        ...quizItem,
        work11Data: {
          ...quizItem.work11Data,
          sentences: chunk
        }
      };
      
      currentPageItems.push(work11Item);
      currentColumnIndex++;
      
      // 2개 단이 채워지면 새 페이지로 이동
      if (currentColumnIndex >= 2) {
        distributedItems.push([...currentPageItems]);
        currentPageItems = [];
        currentColumnIndex = 0;
      }
    });
  } else {
    // 다른 유형들은 기존대로 처리
    currentPageItems.push(quizItem);
    currentColumnIndex++;
    
    // 2개 단이 채워지면 새 페이지로 이동
    if (currentColumnIndex >= 2) {
      distributedItems.push([...currentPageItems]);
      currentPageItems = [];
      currentColumnIndex = 0;
    }
  }
}

// 마지막 페이지 처리
if (currentPageItems.length > 0) {
  distributedItems.push(currentPageItems);
}
```

**동작 원리:**
- `currentColumnIndex`: 현재 단의 위치 추적 (0: 좌측, 1: 우측)
- 유형#11이 아닌 경우: 1개 문제 = 1개 단
- 유형#11인 경우: 문장을 분할하여 각 청크를 별도의 단으로 배치
- 2개 단이 채워지면 `distributedItems`에 페이지 추가

### 4. 전역 문장 번호 계산 (공통)

```typescript
// 전역 문장 번호 계산 (이전 페이지들의 문장 수 고려)
const getGlobalSentenceNumber = (localIndex: number) => {
  let globalNumber = localIndex + 1;
  
  // 현재 페이지 이전의 모든 문장 수 계산
  for (let p = 0; p < pageIndex; p++) {
    const prevPageItems = distributedItems[p];
    prevPageItems.forEach((prevItem: any) => {
      if (prevItem.work11Data && prevItem.work11Data.sentences) {
        globalNumber += prevItem.work11Data.sentences.length;
      }
    });
  }
  
  // 현재 페이지에서 현재 문장 이전의 문장 수 계산
  for (let i = 0; i < index; i++) {
    const prevItem = pageItems[i];
    if (prevItem.work11Data && prevItem.work11Data.sentences) {
      globalNumber += prevItem.work11Data.sentences.length;
    }
  }
  
  return globalNumber;
};
```

**동작 원리:**
- `localIndex`: 현재 청크 내에서의 문장 인덱스 (0부터 시작)
- 이전 페이지들의 모든 유형#11 문장 수를 합산
- 현재 페이지에서 현재 단 이전의 모든 유형#11 문장 수를 합산
- 최종 전역 문장 번호 반환 (01, 02, 03, ...)

## 🔍 패키지#02 vs 패키지#03 비교

### 분할 방식

| 항목 | 패키지#02 | 패키지#03 |
|------|----------|----------|
| 분할 기준 | 높이 계산 | 고정 문장 수 (8개) |
| 문장 수 예측 | 불가능 (동적) | 가능 (고정) |
| 긴 문장 처리 | 자동으로 적게 배치 | 항상 8개 |
| 짧은 문장 처리 | 자동으로 많이 배치 | 항상 8개 |
| 공간 활용 | 최적화됨 | 고정됨 |
| 구현 복잡도 | 높음 | 낮음 |
| 안정성 | 높음 (높이 초과 방지) | 중간 (문장 길이에 따라 넘칠 수 있음) |

### 예시 비교: 12개 문장 (길이 다양)

**패키지#02 (높이 기반)**
```
짧은 문장 6개 (각 50자) + 긴 문장 6개 (각 150자)

1단: 짧은 문장 1~6, 긴 문장 1~3 (약 9개)
2단: 긴 문장 4~6 (약 3개)
```

**패키지#03 (고정 8개)**
```
짧은 문장 6개 (각 50자) + 긴 문장 6개 (각 150자)

1단: 문장 1~8 (길이 무관)
2단: 문장 9~12 (길이 무관)
```

## 📊 실제 동작 예시

### 예시 1: 유형#01, 07, 02, 11(12문장), 13, 14 생성

**패키지#02 (높이 기반)**
```
1페이지 1단(좌측): 유형#01
1페이지 2단(우측): 유형#07

2페이지 1단(좌측): 유형#11 문장 01~09 (짧은 문장이면 더 많이)
2페이지 2단(우측): 유형#11 문장 10~12

3페이지 1단(좌측): 유형#02
3페이지 2단(우측): 유형#13

4페이지 1단(좌측): 유형#14
```

**패키지#03 (고정 8개)**

```
1페이지 1번 단 (좌측): 유형#01
1페이지 2번 단 (우측): 유형#07

2페이지 1번 단 (좌측): 유형#11 문장 01 ~ 08
2페이지 2번 단 (우측): 유형#11 문장 09 ~ 12

3페이지 1번 단 (좌측): 유형#02
3페이지 2번 단 (우측): 유형#13

4페이지 1번 단 (좌측): 유형#14
```

### 예시 2: 유형#01, 11(18문장), 13

```
1페이지 1번 단 (좌측): 유형#01
1페이지 2번 단 (우측): 유형#11 문장 01 ~ 08

2페이지 1번 단 (좌측): 유형#11 문장 09 ~ 16
2페이지 2번 단 (우측): 유형#11 문장 17 ~ 18

3페이지 1번 단 (좌측): 유형#13
```

### 예시 3: 유형#11(5문장), 02, 13

```
1페이지 1번 단 (좌측): 유형#11 문장 01 ~ 05
1페이지 2번 단 (우측): 유형#02

2페이지 1번 단 (좌측): 유형#13
```

## ⚙️ 설정 값

### 커스터마이징 가능한 설정

```typescript
// 1단당 최대 문장 수 (기본값: 8)
const maxSentencesPerColumn: number = 8;

// 페이지당 최대 단 수 (고정값: 2)
const columnsPerPage: number = 2;
```

**조정 시 고려사항:**
- `maxSentencesPerColumn` 증가 → 단당 문장 수 증가 → 글씨 크기 조정 필요
- `maxSentencesPerColumn` 감소 → 페이지 수 증가 → 종이 사용량 증가

## 🎨 CSS 설정

### A4 가로 페이지 템플릿

```css
@page {
  margin: 0;
  size: A4 landscape; /* 가로 페이지 설정 */
}

.a4-landscape-page-template {
  width: 29.7cm; /* 가로 길이 */
  height: 21cm;  /* 세로 길이 */
  page-break-after: always;
  break-after: page;
}

.a4-landscape-page-template:last-child {
  page-break-after: avoid;
  break-after: avoid;
}
```

### 2단 레이아웃

```css
.print-two-column-container {
  display: flex;
  flex-wrap: wrap;
  gap: 0.6cm;
  justify-content: space-between;
  height: 100%;
}

.print-question-card {
  width: calc(50% - 0.3cm); /* 각 단의 너비 */
  break-inside: avoid;
  page-break-inside: avoid;
  margin-bottom: 0.3cm;
  padding: 0.5cm;
}
```

### 유형#11 문장 스타일

```css
.print-sentence-item {
  margin-top: 0 !important;
  margin-bottom: 0.25cm;
  border-bottom: 1px solid #ddd;
  padding-top: 0 !important;
  padding-bottom: 0.15cm;
}

.print-sentence-english {
  font-size: 8.5pt;
  line-height: 1.4;
  color: #000;
  padding: 0 0.15cm 0.15cm 0.15cm !important;
  margin-top: 0 !important;
  margin-bottom: 0.1cm;
}

.sentence-number {
  font-weight: normal;
  color: #000;
  font-size: 8.5pt; /* 영어 문장과 동일한 글씨 크기 */
}
```

## 🔍 참고: 원본 유형#11과의 차이점

### 원본 유형#11 (세로 페이지, 단일 단)

- **페이지 분할**: 새로운 A4 세로 페이지로 넘어감
- **레이아웃**: 1페이지 = 1단 (전체 너비 사용)
- **문장 수**: 동적 계산으로 페이지당 문장 수 결정
- **페이지네이션 로직**: `work11DynamicPagination.ts` 사용

### 패키지#03 유형#11 (가로 페이지, 2단)

- **페이지 분할**: 단으로 먼저 분할, 2단 채워지면 새 페이지
- **레이아웃**: 1페이지 = 2단 (각 단이 50% 너비)
- **문장 수**: 고정값 (1단당 8개 문장)
- **페이지네이션 로직**: `PrintFormatPackage03.tsx` 내부 로직

## 📝 구현 파일 위치

```
src/
└── components/
    └── work/
        └── Package_03_ParagraphOrder/
            ├── Package_03_ParagraphOrder.tsx      # 메인 컴포넌트
            ├── PrintFormatPackage03.tsx           # 인쇄 페이지 (페이지 분할 로직 포함)
            ├── PrintFormatPackage03.css           # 인쇄 페이지 스타일
            └── PrintHeaderPackage03.tsx           # 인쇄 헤더
```

**핵심 로직 위치**: `PrintFormatPackage03.tsx`의 `renderQuizItems()` 함수

## 🚀 향후 개선 방향

### 1. 동적 문장 수 계산
- 현재: 1단당 고정 8개 문장
- 개선: 문장 길이에 따라 동적으로 계산

### 2. 페이지 활용률 최적화
- 현재: 단 분할 기준만 적용
- 개선: 페이지 높이를 고려한 최적 분할

### 3. 커스터마이징 옵션
- 사용자가 단당 문장 수 조정 가능
- 글씨 크기 자동 조정

## ❓ FAQ

### Q1: 단당 문장 수를 변경하려면?
A: `PrintFormatPackage03.tsx`의 `splitWork11Sentences` 함수에서 `maxSentencesPerColumn` 값을 변경하세요.

```typescript
const splitWork11Sentences = (sentences: string[], maxSentencesPerColumn: number = 8)
//                                                                              ↑ 이 값 변경
```

### Q2: 3단 레이아웃으로 변경 가능한가?
A: 가능합니다. `currentColumnIndex >= 2` 부분을 `>= 3`으로 변경하고, CSS의 `.print-question-card` 너비를 `calc(33.33% - 0.4cm)`로 조정하세요.

### Q3: 유형#11의 문장 번호가 연속되지 않는다면?
A: `getGlobalSentenceNumber` 함수가 올바르게 호출되는지 확인하세요. 각 청크의 시작 번호는 이전 모든 문장의 합 + 1이어야 합니다.

---

**작성일**: 2025-10-11  
**버전**: 1.0  
**관련 문서**: 
- [패키지#01 구현 가이드](../README.md)
- [유형#11 페이지분할 로직](./유형#11_페이지분할 로직.md)
- [인쇄레이아웃조절가이드](./인쇄레이아웃조절가이드.md)

