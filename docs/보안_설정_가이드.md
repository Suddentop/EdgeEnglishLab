# 🔒 dothome.co.kr 백엔드 서버 보안 설정 가이드

## 📋 개요

dothome.co.kr PHP 백엔드 서버의 보안을 강화하고 API Key를 안전하게 보호하는 방법을 상세히 설명합니다.

## 🛡️ 보안 아키텍처

### 다층 보안 구조
```
[클라이언트] → [CORS 정책] → [입력 검증] → [요청 제한] → [API 프록시] → [OpenAI API]
     ↓              ↓            ↓            ↓            ↓
  프론트엔드     도메인 제한   악의적 요청   남용 방지    키 숨김
```

### 보안 강화 포인트
- ✅ **API Key 완전 숨김**: 클라이언트에서 API Key 노출 방지
- ✅ **CORS 정책**: 허용된 도메인에서만 접근 가능
- ✅ **입력 검증**: 악의적 요청 자동 차단
- ✅ **요청 제한**: 시간당 300회 제한으로 남용 방지
- ✅ **실시간 모니터링**: 모든 활동 추적 및 로깅

## 🔐 1단계: API Key 보안

### 1.1 API Key 숨김 전략
```php
// ❌ 위험: 클라이언트에서 API Key 노출
const API_KEY = 'your-api-key-here'; // 브라우저에서 노출됨

// ✅ 안전: 서버에서만 API Key 관리
// config.php (서버에서만 접근 가능)
$config = [
    'OPENAI_API_KEY' => 'YOUR_OPENAI_API_KEY_HERE',
];
```

### 1.2 파일 접근 제한
```apache
# .htaccess - 설정 파일 접근 차단
<Files "config.php">
    Order Allow,Deny
    Deny from all
</Files>

<Files ".env*">
    Order Allow,Deny
    Deny from all
</Files>

<Files "*.json">
    Order Allow,Deny
    Deny from all
</Files>
```

### 1.3 환경 변수 보안
```php
// config.php - 환경 변수 우선 사용
$OPENAI_API_KEY = getenv('OPENAI_API_KEY') ?: 'fallback_api_key_here';

// 환경 변수가 설정되지 않은 경우 경고
if (!$OPENAI_API_KEY || $OPENAI_API_KEY === 'fallback_api_key_here') {
    error_log('WARNING: OpenAI API Key not properly configured');
}
```

## 🌐 2단계: CORS 보안 정책

### 2.1 기본 CORS 설정
```apache
# .htaccess - CORS 헤더 설정
<IfModule mod_headers.c>
    # 허용된 도메인만 접근 가능
    Header always set Access-Control-Allow-Origin "https://edgeenglish.net"
    Header always set Access-Control-Allow-Methods "POST, GET, OPTIONS"
    Header always set Access-Control-Allow-Headers "Content-Type, Authorization"
    Header always set Access-Control-Max-Age "3600"
    
    # 보안 헤더 추가
    Header always set X-Content-Type-Options "nosniff"
    Header always set X-Frame-Options "DENY"
    Header always set X-XSS-Protection "1; mode=block"
    Header always set Referrer-Policy "strict-origin-when-cross-origin"
</IfModule>
```

### 2.2 동적 CORS 검증
```php
// secure-api-proxy.php - 동적 CORS 검증
$allowedOrigins = [
    'https://edgeenglish.net',
    'https://www.edgeenglish.net'
];

$origin = $_SERVER['HTTP_ORIGIN'] ?? '';
if (in_array($origin, $allowedOrigins)) {
    header("Access-Control-Allow-Origin: $origin");
} else {
    http_response_code(403);
    echo json_encode(['error' => 'Origin not allowed']);
    exit();
}
```

### 2.3 OPTIONS 요청 처리
```php
// CORS preflight 요청 처리
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    header('Access-Control-Allow-Origin: ' . $origin);
    header('Access-Control-Allow-Methods: POST, GET, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type, Authorization');
    header('Access-Control-Max-Age: 3600');
    http_response_code(200);
    exit();
}
```

## 🔍 3단계: 입력 검증 및 필터링

### 3.1 요청 검증 함수
```php
function validateRequest($data) {
    // 필수 필드 확인
    if (!isset($data['model']) || !isset($data['messages'])) {
        return ['valid' => false, 'error' => 'Missing required fields'];
    }

    // 모델 허용 목록
    $allowedModels = ['gpt-4o', 'gpt-4', 'gpt-3.5-turbo'];
    if (!in_array($data['model'], $allowedModels)) {
        return ['valid' => false, 'error' => 'Invalid model'];
    }

    // 메시지 개수 제한
    if (!is_array($data['messages']) || count($data['messages']) > 50) {
        return ['valid' => false, 'error' => 'Too many messages'];
    }

    // 토큰 수 제한
    if (isset($data['max_tokens']) && $data['max_tokens'] > 4000) {
        return ['valid' => false, 'error' => 'Token limit exceeded'];
    }

    // 온도 값 검증
    if (isset($data['temperature']) && ($data['temperature'] < 0 || $data['temperature'] > 2)) {
        return ['valid' => false, 'error' => 'Invalid temperature value'];
    }

    return ['valid' => true];
}
```

### 3.2 악의적 입력 필터링
```php
function sanitizeInput($input) {
    // HTML 태그 제거
    $input = strip_tags($input);
    
    // 특수 문자 이스케이프
    $input = htmlspecialchars($input, ENT_QUOTES, 'UTF-8');
    
    // 길이 제한
    if (strlen($input) > 50000) {
        return substr($input, 0, 50000);
    }
    
    return $input;
}

function validateMessages($messages) {
    foreach ($messages as $message) {
        if (!isset($message['role']) || !isset($message['content'])) {
            return false;
        }
        
        $allowedRoles = ['system', 'user', 'assistant'];
        if (!in_array($message['role'], $allowedRoles)) {
            return false;
        }
        
        // 메시지 내용 길이 제한
        if (strlen($message['content']) > 10000) {
            return false;
        }
    }
    
    return true;
}
```

### 3.3 SQL 인젝션 방지
```php
// 데이터베이스 사용 시 PDO 준비문 사용
function logRequest($clientId, $endpoint, $responseTime, $success) {
    $pdo = new PDO($dsn, $username, $password);
    
    $stmt = $pdo->prepare("
        INSERT INTO api_logs 
        (client_id, endpoint, response_time, success, created_at) 
        VALUES (?, ?, ?, ?, NOW())
    ");
    
    $stmt->execute([
        $clientId,
        $endpoint,
        $responseTime,
        $success ? 1 : 0
    ]);
}
```

## 🚦 4단계: 요청 제한 및 Rate Limiting

### 4.1 기본 Rate Limiting
```php
class SecureRateLimiter {
    private $storageFile;
    private $maxRequests;
    private $timeWindow;
    
    public function __construct($maxRequests = 300, $timeWindow = 3600) {
        $this->storageFile = 'secure_rate_limit.json';
        $this->maxRequests = $maxRequests;
        $this->timeWindow = $timeWindow;
    }
    
    public function checkRateLimit($identifier = null) {
        if (!$identifier) {
            $identifier = $this->getSecureClientIdentifier();
        }
        
        $data = $this->loadData();
        $currentTime = time();
        
        // 오래된 데이터 정리
        if (isset($data[$identifier])) {
            $data[$identifier] = array_filter($data[$identifier], function($timestamp) use ($currentTime) {
                return ($currentTime - $timestamp) < $this->timeWindow;
            });
        }
        
        $requestCount = isset($data[$identifier]) ? count($data[$identifier]) : 0;
        
        if ($requestCount >= $this->maxRequests) {
            $this->logRateLimitExceeded($identifier, $requestCount);
            return false;
        }
        
        // 새 요청 기록
        $data[$identifier][] = $currentTime;
        $this->saveData($data);
        
        return true;
    }
    
    private function getSecureClientIdentifier() {
        $ip = $_SERVER['REMOTE_ADDR'] ?? 'unknown';
        $userAgent = $_SERVER['HTTP_USER_AGENT'] ?? 'unknown';
        $forwardedFor = $_SERVER['HTTP_X_FORWARDED_FOR'] ?? '';
        
        // 해시화하여 개인정보 보호
        return hash('sha256', $ip . $userAgent . $forwardedFor);
    }
    
    private function logRateLimitExceeded($identifier, $count) {
        $logMessage = sprintf(
            "[RATE_LIMIT] Client %s exceeded limit: %d requests in %d seconds",
            substr($identifier, 0, 8),
            $count,
            $this->timeWindow
        );
        error_log($logMessage);
    }
}
```

### 4.2 고급 Rate Limiting 전략
```php
class AdvancedRateLimiter {
    private $pdo;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    public function checkAdvancedRateLimit($clientId, $endpoint = null) {
        // 엔드포인트별 제한
        $limits = [
            'chat/completions' => 300,
            'embeddings' => 1000,
            'images/generations' => 50
        ];
        
        $limit = $limits[$endpoint] ?? 300;
        
        $stmt = $this->pdo->prepare("
            SELECT COUNT(*) as count 
            FROM api_requests 
            WHERE client_id = ? 
            AND endpoint = ? 
            AND created_at > DATE_SUB(NOW(), INTERVAL 1 HOUR)
        ");
        
        $stmt->execute([$clientId, $endpoint]);
        $result = $stmt->fetch();
        
        return $result['count'] < $limit;
    }
    
    public function recordRequest($clientId, $endpoint, $responseTime, $success) {
        $stmt = $this->pdo->prepare("
            INSERT INTO api_requests 
            (client_id, endpoint, response_time, success, created_at) 
            VALUES (?, ?, ?, ?, NOW())
        ");
        
        $stmt->execute([$clientId, $endpoint, $responseTime, $success ? 1 : 0]);
    }
}
```

## 📊 5단계: 로깅 및 모니터링

### 5.1 보안 로깅 시스템
```php
class SecurityLogger {
    private $logFile;
    
    public function __construct($logFile = 'security_logs.txt') {
        $this->logFile = $logFile;
    }
    
    public function logSecurityEvent($event, $details = []) {
        $timestamp = date('Y-m-d H:i:s');
        $ip = $_SERVER['REMOTE_ADDR'] ?? 'unknown';
        $userAgent = $_SERVER['HTTP_USER_AGENT'] ?? 'unknown';
        
        $logEntry = [
            'timestamp' => $timestamp,
            'event' => $event,
            'ip' => $ip,
            'user_agent' => substr($userAgent, 0, 100),
            'details' => $details
        ];
        
        $logLine = json_encode($logEntry) . "\n";
        file_put_contents($this->logFile, $logLine, FILE_APPEND | LOCK_EX);
        
        // 위험한 이벤트는 즉시 알림
        if (in_array($event, ['RATE_LIMIT_EXCEEDED', 'INVALID_REQUEST', 'SUSPICIOUS_ACTIVITY'])) {
            $this->sendSecurityAlert($event, $logEntry);
        }
    }
    
    private function sendSecurityAlert($event, $details) {
        // 이메일 알림
        $to = 'security@edgeenglish.net';
        $subject = "[SECURITY ALERT] $event";
        $body = "Security event detected:\n" . json_encode($details, JSON_PRETTY_PRINT);
        
        mail($to, $subject, $body);
    }
}
```

### 5.2 실시간 모니터링
```php
class SecurityMonitor {
    private $securityLogger;
    
    public function __construct() {
        $this->securityLogger = new SecurityLogger();
    }
    
    public function monitorRequest($request) {
        // 의심스러운 패턴 감지
        if ($this->detectSuspiciousPattern($request)) {
            $this->securityLogger->logSecurityEvent('SUSPICIOUS_ACTIVITY', [
                'pattern' => 'detected',
                'request' => $request
            ]);
        }
        
        // 대량 요청 감지
        if ($this->detectBulkRequests($request)) {
            $this->securityLogger->logSecurityEvent('BULK_REQUEST_DETECTED', [
                'count' => $request['count']
            ]);
        }
    }
    
    private function detectSuspiciousPattern($request) {
        // SQL 인젝션 패턴
        $sqlPatterns = ['UNION', 'SELECT', 'DROP', 'INSERT', 'DELETE'];
        $requestString = json_encode($request);
        
        foreach ($sqlPatterns as $pattern) {
            if (stripos($requestString, $pattern) !== false) {
                return true;
            }
        }
        
        return false;
    }
    
    private function detectBulkRequests($request) {
        // 1분 내 50회 이상 요청
        // 구현 로직...
        return false;
    }
}
```

## 🔐 6단계: 추가 보안 강화

### 6.1 IP 화이트리스트/블랙리스트
```php
class IPFilter {
    private $whitelist = [];
    private $blacklist = [];
    
    public function __construct() {
        $this->loadIPLists();
    }
    
    public function isAllowed($ip) {
        // 블랙리스트 확인
        if (in_array($ip, $this->blacklist)) {
            return false;
        }
        
        // 화이트리스트가 있으면 화이트리스트만 허용
        if (!empty($this->whitelist)) {
            return in_array($ip, $this->whitelist);
        }
        
        return true;
    }
    
    private function loadIPLists() {
        $this->whitelist = [
            // 허용된 IP 목록
        ];
        
        $this->blacklist = [
            // 차단된 IP 목록
        ];
    }
}
```

### 6.2 API 키 기반 인증
```php
class APIKeyAuthenticator {
    private $validKeys = [];
    
    public function __construct() {
        $this->loadValidKeys();
    }
    
    public function authenticate($apiKey) {
        if (empty($apiKey)) {
            return false;
        }
        
        $hashedKey = hash('sha256', $apiKey);
        return in_array($hashedKey, $this->validKeys);
    }
    
    private function loadValidKeys() {
        $this->validKeys = [
            hash('sha256', 'client_secret_key_1'),
            hash('sha256', 'client_secret_key_2'),
            // 추가 키들...
        ];
    }
}
```

### 6.3 암호화 통신
```php
class SecureCommunication {
    private $encryptionKey;
    
    public function __construct($key) {
        $this->encryptionKey = $key;
    }
    
    public function encrypt($data) {
        $iv = openssl_random_pseudo_bytes(16);
        $encrypted = openssl_encrypt($data, 'AES-256-CBC', $this->encryptionKey, 0, $iv);
        return base64_encode($iv . $encrypted);
    }
    
    public function decrypt($encryptedData) {
        $data = base64_decode($encryptedData);
        $iv = substr($data, 0, 16);
        $encrypted = substr($data, 16);
        return openssl_decrypt($encrypted, 'AES-256-CBC', $this->encryptionKey, 0, $iv);
    }
}
```

## 🚨 7단계: 보안 사고 대응

### 7.1 침입 탐지 시스템
```php
class IntrusionDetectionSystem {
    private $securityLogger;
    private $suspiciousActivities = [];
    
    public function __construct() {
        $this->securityLogger = new SecurityLogger();
    }
    
    public function detectIntrusion($request) {
        $riskScore = 0;
        
        // 의심스러운 요청 패턴 감지
        if ($this->detectSQLInjection($request)) {
            $riskScore += 50;
            $this->suspiciousActivities[] = 'SQL_INJECTION_ATTEMPT';
        }
        
        if ($this->detectXSSAttempt($request)) {
            $riskScore += 30;
            $this->suspiciousActivities[] = 'XSS_ATTEMPT';
        }
        
        if ($this->detectPathTraversal($request)) {
            $riskScore += 40;
            $this->suspiciousActivities[] = 'PATH_TRAVERSAL_ATTEMPT';
        }
        
        // 위험 점수가 임계값을 초과하면 침입으로 판단
        if ($riskScore > 70) {
            $this->handleIntrusion($request, $riskScore);
            return true;
        }
        
        return false;
    }
    
    private function handleIntrusion($request, $riskScore) {
        // 즉시 차단
        $this->blockIP($_SERVER['REMOTE_ADDR']);
        
        // 보안 로그 기록
        $this->securityLogger->logSecurityEvent('INTRUSION_DETECTED', [
            'risk_score' => $riskScore,
            'activities' => $this->suspiciousActivities,
            'request' => $request
        ]);
        
        // 관리자에게 즉시 알림
        $this->sendUrgentAlert($request, $riskScore);
    }
}
```

### 7.2 자동 차단 시스템
```php
class AutoBlockSystem {
    private $blockedIPs = [];
    
    public function blockIP($ip, $reason = 'Security violation') {
        $this->blockedIPs[$ip] = [
            'blocked_at' => time(),
            'reason' => $reason,
            'expires_at' => time() + 3600 // 1시간 차단
        ];
        
        $this->saveBlockedIPs();
        
        error_log("IP $ip blocked: $reason");
    }
    
    public function isBlocked($ip) {
        if (!isset($this->blockedIPs[$ip])) {
            return false;
        }
        
        $blockInfo = $this->blockedIPs[$ip];
        
        // 차단 시간 만료 확인
        if (time() > $blockInfo['expires_at']) {
            unset($this->blockedIPs[$ip]);
            $this->saveBlockedIPs();
            return false;
        }
        
        return true;
    }
    
    private function saveBlockedIPs() {
        file_put_contents('blocked_ips.json', json_encode($this->blockedIPs));
    }
}
```

## 📋 보안 체크리스트

### 배포 전 보안 점검
- [ ] API Key가 클라이언트에서 완전히 숨겨짐
- [ ] CORS 정책이 올바르게 설정됨
- [ ] 입력 검증이 모든 엔드포인트에 적용됨
- [ ] Rate Limiting이 정상 작동함
- [ ] 로깅 시스템이 모든 활동을 기록함
- [ ] 보안 헤더가 설정됨
- [ ] 파일 접근 권한이 적절히 설정됨

### 운영 중 보안 모니터링
- [ ] 보안 로그를 정기적으로 검토
- [ ] 의심스러운 활동을 실시간 모니터링
- [ ] API 사용량을 정기적으로 분석
- [ ] 침입 시도에 대한 즉시 대응
- [ ] 보안 패치를 정기적으로 적용

### 정기 보안 점검
- [ ] API Key 주기적 교체 (3개월마다)
- [ ] 보안 설정 정기 검토 (월 1회)
- [ ] 침투 테스트 실행 (분기 1회)
- [ ] 백업 및 복구 계획 검토 (월 1회)

---

## 🎯 보안 목표

### 주요 보안 지표
- **API Key 노출**: 0건
- **성공적인 침입**: 0건
- **데이터 유출**: 0건
- **서비스 중단**: 0건

### 보안 성능 지표
- **보안 사고 탐지 시간**: 5분 이내
- **침입 차단 시간**: 1분 이내
- **보안 로그 완성도**: 100%
- **보안 패치 적용률**: 100%

**이 가이드를 따라하면 dothome.co.kr에서 안전하고 보안이 강화된 백엔드 서버를 운영할 수 있습니다!** 🔒
