/**
 * Work_03 (ë¹ˆì¹¸ ë‹¨ì–´ ë¬¸ì œ) ë¬¸ì œ ìƒì„± ë¡œì§
 * ì›ë³¸: src/components/work/Work_03_VocabularyWord/Work_03_VocabularyWord.tsx
 * 
 * ì´ íŒŒì¼ì€ ì›ë³¸ ì»´í¬ë„ŒíŠ¸ì—ì„œ ë¬¸ì œ ìƒì„± ë¡œì§ë§Œ ì¶”ì¶œí•œ ê²ƒì…ë‹ˆë‹¤.
 * ì›ë³¸ íŒŒì¼ì€ ìˆ˜ì •í•˜ì§€ ì•Šì•˜ìœ¼ë©°, ë¡œì§ì„ ë³µì‚¬í•˜ì—¬ ë…ë¦½ì ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */

import { callOpenAI } from './common';

/**
 * ë¹ˆì¹¸ ë¬¸ì œ íƒ€ì… ì •ì˜
 */
export interface BlankQuiz {
  blankedText: string;
  options: string[];
  answerIndex: number;
}

/**
 * ìœ í˜•#03: ë¹ˆì¹¸(ë‹¨ì–´) ë¬¸ì œ ìƒì„±
 * @param passage - ì˜ì–´ ë³¸ë¬¸
 * @returns ë¹ˆì¹¸ ë¬¸ì œ ë°ì´í„°
 */
export async function generateWork03Quiz(passage: string): Promise<BlankQuiz> {
  console.log('ğŸ” Work_03 ë¬¸ì œ ìƒì„± ì‹œì‘...');
  console.log('ğŸ“ ì…ë ¥ í…ìŠ¤íŠ¸ ê¸¸ì´:', passage.length);

  try {
    // passageì—ì„œ ì´ë¯¸ ()ë¡œ ë¬¶ì¸ ë‹¨ì–´ ì¶”ì¶œ (ì œì™¸ ëŒ€ìƒ)
    const excludedWords: string[] = [];
    const bracketRegex = /\(([^)]+)\)/g;
    let match;
    while ((match = bracketRegex.exec(passage)) !== null) {
      excludedWords.push(match[1].trim());
    }
    
    const prompt = `ì•„ë˜ ì˜ì–´ ë³¸ë¬¸ì—ì„œ ê¸€ì˜ ì£¼ì œì™€ ê°€ì¥ ë°€ì ‘í•œ, ì˜ë¯¸ ìˆëŠ” ë‹¨ì–´(ëª…ì‚¬, í‚¤ì›Œë“œ ë“±) 1ê°œë¥¼ ì„ ì •í•´.

1. ë°˜ë“œì‹œ ë³¸ë¬¸ì— ì‹¤ì œë¡œ ë“±ì¥í•œ ë‹¨ì–´(ì² ì, í˜•íƒœ, ëŒ€ì†Œë¬¸ìê¹Œì§€ ë™ì¼)ë¥¼ ì •ë‹µìœ¼ë¡œ ì„ ì •í•´ì•¼ í•´. ë³€í˜•, ëŒ€ì²´, ë™ì˜ì–´, ì–´í˜• ë³€í™” ì—†ì´ ë³¸ë¬¸ì— ìˆë˜ ê·¸ëŒ€ë¡œ ì‚¬ìš©í•´ì•¼ í•´.

2. ë¬¸ì œì˜ ë³¸ë¬¸(ë¹ˆì¹¸ í¬í•¨)ì€ ë°˜ë“œì‹œ ì‚¬ìš©ìê°€ ì…ë ¥í•œ ì „ì²´ ë³¸ë¬¸ê³¼ ì™„ì „íˆ ë™ì¼í•´ì•¼ í•˜ë©°, ì¼ë¶€ ë¬¸ì¥ë§Œ ì¶”ì¶œí•˜ê±°ë‚˜, ë¬¸ì¥ ìˆœì„œë¥¼ ë°”ê¾¸ê±°ë‚˜, ë³¸ë¬¸ì„ ìš”ì•½/ë³€í˜•í•´ì„œëŠ” ì•ˆ ë¼. ì˜¤ì§ ì •ë‹µ ë‹¨ì–´ë§Œ ()ë¡œ ì¹˜í™˜í•´.

3. ì…ë ¥ëœ ë³¸ë¬¸ì— ì´ë¯¸ ()ë¡œ ë¬¶ì¸ ë‹¨ì–´ë‚˜ êµ¬ê°€ ìˆë‹¤ë©´, ê·¸ ë¶€ë¶„ì€ ì ˆëŒ€ ë¹ˆì¹¸ ì²˜ë¦¬ ëŒ€ìƒìœ¼ë¡œ ì‚¼ì§€ ë§ˆì„¸ìš”. ë°˜ë“œì‹œ ê´„í˜¸ ë°–ì— ìˆëŠ” ë‹¨ì–´ë§Œ ë¹ˆì¹¸ í›„ë³´ë¡œ ì„ ì •í•˜ì„¸ìš”.

4. ì•„ë˜ ë‹¨ì–´/êµ¬ëŠ” ì ˆëŒ€ ë¹ˆì¹¸ ì²˜ë¦¬í•˜ì§€ ë§ˆì„¸ìš”: ${excludedWords.length > 0 ? excludedWords.join(', ') : 'ì—†ìŒ'}

5. ì •ë‹µ(í•µì‹¬ë‹¨ì–´) + ì˜¤ë‹µ(ë¹„ìŠ·í•œ í’ˆì‚¬ì˜ ë‹¨ì–´ 4ê°œ, ì˜ë¯¸ëŠ” ë‹¤ë¦„) ì´ 5ê°œë¥¼ ìƒì„±í•´.

6. ì •ë‹µì˜ ìœ„ì¹˜ëŠ” 1~5ë²ˆ ì¤‘ ëœë¤.

7. JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µí•˜ì„¸ìš”:

{
  "options": ["ì„ íƒì§€1", "ì„ íƒì§€2", "ì„ íƒì§€3", "ì„ íƒì§€4", "ì„ íƒì§€5"],
  "answerIndex": 0
}

ì…ë ¥ëœ ì˜ì–´ ë³¸ë¬¸:
${passage}`;

    const response = await callOpenAI({
      model: 'gpt-4o',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 1200,
      temperature: 0.7
    });

    if (!response.ok) {
      throw new Error(`OpenAI API ì˜¤ë¥˜: ${response.status}`);
    }

    const data = await response.json();
    console.log('AI ì‘ë‹µ ì „ì²´:', data);
    console.log('AI ì‘ë‹µ ë‚´ìš©:', data.choices[0].message.content);
    
    const jsonMatch = data.choices[0].message.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) throw new Error('AI ì‘ë‹µì—ì„œ JSON í˜•ì‹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    
    console.log('ì¶”ì¶œëœ JSON:', jsonMatch[0]);
    
    let result: any;
    try {
      result = JSON.parse(jsonMatch[0]);
      console.log('íŒŒì‹±ëœ ê²°ê³¼:', result);
    } catch {
      throw new Error('AI ì‘ë‹µì˜ JSON í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    }

    // ì •ë‹µ ë‹¨ì–´ê°€ ë³¸ë¬¸ì— ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ”ì§€ ê²€ì¦
    if (!passage.includes(result.options[result.answerIndex])) {
      throw new Error('ì •ë‹µ ë‹¨ì–´ê°€ ë³¸ë¬¸ì— ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. AI ì‘ë‹µ ì˜¤ë¥˜ì…ë‹ˆë‹¤.');
    }

    // blankedTextë¥¼ í”„ë¡ íŠ¸ì—”ë“œì—ì„œ ì§ì ‘ ìƒì„± (ê´„í˜¸ split ë°©ì‹, ê´„í˜¸ ì•ˆ/ë°– ì™„ë²½ êµ¬ë¶„)
    function replaceFirstOutsideBrackets(text: string, word: string): string {
      let replaced = false;
      // ê´„í˜¸ë¡œ split (ê´„í˜¸ ì•ˆ/ë°– êµ¬ë¶„)
      const tokens = text.split(/([()])/);
      let inBracket = false;
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i] === '(') {
          inBracket = true;
          continue;
        }
        if (tokens[i] === ')') {
          inBracket = false;
          continue;
        }
        if (!inBracket && !replaced) {
          // ê´„í˜¸ ë°–ì—ì„œë§Œ ë‹¨ì–´ ì¹˜í™˜ (ë‹¨ì–´ ê²½ê³„ ì²´í¬)
          const regex = new RegExp(`\\b${word}\\b`);
          if (regex.test(tokens[i])) {
            tokens[i] = tokens[i].replace(regex, '(__________)');
            replaced = true;
          }
        }
      }
      // splitìœ¼ë¡œ ê´„í˜¸ê°€ ì‚¬ë¼ì§€ë¯€ë¡œ, ë‹¤ì‹œ ì¡°ë¦½
      let result = '';
      inBracket = false;
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i] === '(') {
          inBracket = true;
          result += '(';
          continue;
        }
        if (tokens[i] === ')') {
          inBracket = false;
          result += ')';
          continue;
        }
        result += tokens[i];
      }
      return result;
    }

    const answer = result.options[result.answerIndex];
    const blankedText = replaceFirstOutsideBrackets(passage, answer);
    result.blankedText = blankedText;
    
    // ë¹ˆì¹¸ ë³¸ë¬¸ì´ ì›ë³¸ ë³¸ë¬¸ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì¦
    const blankRestore = result.blankedText.replace(/\( *_{6,}\)/, answer);
    if (blankRestore.trim() !== passage.trim()) {
      throw new Error('ë¹ˆì¹¸ ë³¸ë¬¸ì´ ì›ë³¸ ë³¸ë¬¸ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. AI ì‘ë‹µ ì˜¤ë¥˜ì…ë‹ˆë‹¤.');
    }
    
    console.log('ìµœì¢… ê²€ì¦ ì „ ê²°ê³¼:', {
      blankedText: result.blankedText,
      options: result.options,
      answerIndex: result.answerIndex
    });
    
    if (!result.blankedText || !result.options || typeof result.answerIndex !== 'number') {
      throw new Error('AI ì‘ë‹µì— í•„ìˆ˜ í•„ë“œê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }
    
    console.log('âœ… Work_03 ë¬¸ì œ ìƒì„± ì™„ë£Œ:', result);
    return result;
    
  } catch (error) {
    console.error('âŒ Work_03 ë¬¸ì œ ìƒì„± ì‹¤íŒ¨:', error);
    throw error;
  }
}

