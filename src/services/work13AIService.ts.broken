// Work13 (ë¹ˆì¹¸ ì±„ìš°ê¸° ë‹¨ì–´) ê´€ë ¨ AI ì„œë¹„ìŠ¤ í•¨ìˆ˜ë“¤
import { openAIProxyService } from './openaiProxyService';

export interface BlankFillItem {
  blankedText: string;
  correctAnswers: string[]; // ê° ë¹ˆì¹¸ì˜ ì •ë‹µ ë°°ì—´
  translation: string;
  userAnswer: string;
  isCorrect: boolean | null;
  reasoning?: string; // ì£¼ì œì–´ ì„ ì • ì´ìœ 
}

export interface Work_13_BlankFillWordData {
  title: string;
  items: BlankFillItem[];
}

// ë¬¸ì¥ ë¶„í•  í•¨ìˆ˜ (ê°œì„ ëœ ë²„ì „)
export const splitSentences = (text: string): string[] => {
  // 1. ë¨¼ì € ë¬¸ì¥ ë êµ¬ë¶„ìë¡œ ë¶„í• 
  let sentences = text
    .split(/(?<=[.!?])\s+/)
    .map(s => s.trim())
    .filter(s => s.length > 0);
  
  // 2. ë¬¸ì¥ì´ ë„ˆë¬´ ì ìœ¼ë©´ ë‹¤ë¥¸ ë°©ë²•ìœ¼ë¡œ ë¶„í•  ì‹œë„
  if (sentences.length < 2) {
    // ë§ˆì¹¨í‘œë¡œë§Œ ë¶„í• 
    sentences = text
      .split(/\.\s+/)
      .map(s => s.trim())
      .filter(s => s.length > 0);
  }
  
  // 3. ì—¬ì „íˆ ë¬¸ì¥ì´ ì ìœ¼ë©´ ì„¸ë¯¸ì½œë¡ ìœ¼ë¡œë„ ë¶„í• 
  if (sentences.length < 2) {
    const semicolonSplit = text
      .split(/;\s+/)
      .map(s => s.trim())
      .filter(s => s.length > 0);
    
    if (semicolonSplit.length > sentences.length) {
      sentences = semicolonSplit;
    }
  }
  
  // 4. ê° ë¬¸ì¥ì˜ ëì— ë§ˆì¹¨í‘œê°€ ì—†ìœ¼ë©´ ì¶”ê°€
  sentences = sentences.map(sentence => {
    if (!sentence.match(/[.!?]$/)) {
      return sentence + '.';
    }
    return sentence;
  });
  
  console.log('ë¬¸ì¥ ë¶„í•  ê²°ê³¼:', {
    ì›ë³¸í…ìŠ¤íŠ¸: text.substring(0, 100) + '...',
    ë¶„í• ëœë¬¸ì¥ìˆ˜: sentences.length,
    ë¬¸ì¥ë“¤: sentences.map((s, i) => `${i+1}. ${s.substring(0, 50)}...`)
  });
  
  return sentences;
};

// ë¬¸ì¥ì˜ ë‹¨ì–´ ìˆ˜ ê³„ì‚°
export const countWordsInSentence = (sentence: string): number => {
  return sentence.trim().split(/\s+/).filter(word => word.length > 0).length;
};

// ìœ íš¨í•œ ë¬¸ì¥ í•„í„°ë§
export const filterValidSentences = (sentences: string[]): { 
  validSentences: string[], 
  skippedSentences: string[] 
} => {
  const validSentences: string[] = [];
  const skippedSentences: string[] = [];
  
  for (const sentence of sentences) {
    const wordCount = countWordsInSentence(sentence);
    
    // 5-50ë‹¨ì–´ ì‚¬ì´ì˜ ë¬¸ì¥ë§Œ ìœ íš¨
    if (wordCount >= 5 && wordCount <= 50) {
      validSentences.push(sentence);
    } else {
      skippedSentences.push(sentence);
    }
  }
  
  return { validSentences, skippedSentences };
};

// ì´ë¯¸ì§€ â†’ í…ìŠ¤íŠ¸ (OpenAI Vision API)
export const imageToTextWithOpenAIVision = async (imageFile: File): Promise<string> => {
  const fileToBase64 = (file: File) => new Promise<string>((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
  
  const base64 = await fileToBase64(imageFile);
  const apiKey = process.env.REACT_APP_OPENAI_API_KEY as string;
  
  const prompt = `ì˜ì–´ë¬¸ì œë¡œ ì‚¬ìš©ë˜ëŠ” ë³¸ë¬¸ì´ì•¼.
ì´ ì´ë¯¸ì§€ì˜ ë‚´ìš©ì„ ìˆ˜ì‘ì—…ìœ¼ë¡œ ì •í™•íˆ ì½ê³ , ì˜ì–´ ë³¸ë¬¸ë§Œ ì¶”ë ¤ë‚´ì„œ ë³´ì—¬ì¤˜.
ê¸€ìëŠ” ì¸ì‡„ê¸€ì”¨ì²´ ì´ì™¸ì— ì†ê¸€ì”¨ë‚˜ ì›, ë°‘ì¤„ ë“± í‘œì‹œë˜ì–´ìˆëŠ” ê²ƒì€ ë¬´ì‹œí•´. 
ë³¸ë¬¸ì¤‘ì— ì›ë¬¸ì 1, 2, 3... ë“±ìœ¼ë¡œ í‘œì‹œëœê±´ ì œê±°í•´ì¤˜. 
ì›ë¬¸ì ì œê±°í›„ ì¤„ì„ ë°”ê¾¸ê±°ë‚˜ ë¬¸ë‹¨ì„ ë°”ê¾¸ì§€ë§ê³ , ì „ì²´ê°€ í•œ ë¬¸ë‹¨ìœ¼ë¡œ êµ¬ì„±í•´ì¤˜. 
ì˜ì–´ ë³¸ë¬¸ë§Œ, ì•„ë¬´ëŸ° ì„¤ëª…ì´ë‚˜ ì•ˆë‚´ë¬¸ ì—†ì´, í•œ ë¬¸ë‹¨ìœ¼ë¡œë§Œ ì¶œë ¥í•´ì¤˜.`;
  
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model: 'gpt-4o',
      messages: [
        { role: 'user', content: [
            { type: 'text', text: prompt },
            { type: 'image_url', image_url: { url: base64 } }
          ]
        }
      ],
      max_tokens: 2048
    })
  });
  
  const data = await response.json();
  return data.choices[0].message.content.trim();
};

// OpenAI APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜ì–´ë¥¼ í•œê¸€ë¡œ ë²ˆì—­
export const translateToKorean = async (englishText: string): Promise<string> => {
  try {
    console.log('ğŸŒ ë²ˆì—­ ì‹œì‘:', englishText.substring(0, 50) + '...');

    const prompt = `ë‹¤ìŒ ì˜ì–´ ë³¸ë¬¸ì„ ìì—°ìŠ¤ëŸ¬ìš´ í•œêµ­ì–´ë¡œ ë²ˆì—­í•˜ì„¸ìš”.

ë²ˆì—­ ìš”êµ¬ì‚¬í•­:
- ìì—°ìŠ¤ëŸ½ê³  ë§¤ë„ëŸ¬ìš´ í•œêµ­ì–´
- ì›ë¬¸ì˜ ì˜ë¯¸ë¥¼ ì •í™•íˆ ì „ë‹¬
- ë¬¸í•™ì ì´ê³  ì½ê¸° ì‰¬ìš´ ë¬¸ì²´

ë²ˆì—­ë§Œ ë°˜í™˜í•˜ì„¸ìš” (ë‹¤ë¥¸ í…ìŠ¤íŠ¸ ì—†ì´):

${englishText}`;

    const request = {
        model: 'gpt-3.5-turbo',
        messages: [
          { role: 'system', content: 'You are a helpful assistant that provides natural Korean translations.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.3,
        max_tokens: 800,
    };

    const data = await openAIProxyService.callOpenAI(request);
    console.log('âœ… ë²ˆì—­ ì™„ë£Œ');
    
    if (!data.choices || !data.choices[0] || !data.choices[0].message) {
      throw new Error('API ì‘ë‹µ í˜•ì‹ ì˜¤ë¥˜');
    }
    
    return data.choices[0].message.content.trim();
  } catch (error) {
    console.error('âŒ ë²ˆì—­ ì˜¤ë¥˜:', error);
    throw error;
  }
};

// ë³¸ë¬¸ â†’ ë¹ˆì¹¸ ì±„ìš°ê¸° ë¬¸ì œ ìƒì„± (AI) - ë¬¸ì¥ë³„ë¡œ ì£¼ì œì–´(í•µì‹¬ ì˜ë¯¸ ë‹¨ì–´) 1ê°œì”© ì„ íƒ
export const generateBlankFillQuizWithAI = async (passage: string, retryCount: number = 0): Promise<BlankFillItem> => {
  
  // ë¨¼ì € ë¬¸ì¥ì„ ë¶„í• í•˜ê³  í•„í„°ë§
  const allSentences = splitSentences(passage);
  const { validSentences, skippedSentences } = filterValidSentences(allSentences);
  
  console.log('ë¬¸ì¥ ë¶„ì„ (AI í˜¸ì¶œ ì „):', {
    ì „ì²´ë¬¸ì¥ìˆ˜: allSentences.length,
    ìœ íš¨ë¬¸ì¥ìˆ˜: validSentences.length,
    ì œì™¸ë¬¸ì¥ìˆ˜: skippedSentences.length,
    ì œì™¸ëœë¬¸ì¥ë“¤: skippedSentences.map(s => `${s.substring(0, 30)}... (${countWordsInSentence(s)}ê°œ ë‹¨ì–´)`)
  });
  
  // ë¬¸ì¥ë³„ë¡œ ëª…í™•íˆ êµ¬ë¶„ëœ í”„ë¡¬í”„íŠ¸ ìƒì„±
  const sentenceList = validSentences.map((sentence, index) => 
    `ë¬¸ì¥ ${index + 1}: "${sentence}"`
  ).join('\n\n');
  
  const prompt = `ë‹¤ìŒ ${validSentences.length}ê°œ ë¬¸ì¥ì—ì„œ ê° ë¬¸ì¥ë§ˆë‹¤ í•µì‹¬ ë‹¨ì–´ 1ê°œì”©ì„ ì„ íƒí•˜ì„¸ìš”.

**ë¬¸ì¥ ëª©ë¡:**
${sentenceList}

**ì‘ì—… ë°©ë²•:**
1. ë¬¸ì¥ 1ì„ ì½ê³  â†’ í•µì‹¬ ë‹¨ì–´ 1ê°œ ì„ íƒ
2. ë¬¸ì¥ 2ë¥¼ ì½ê³  â†’ í•µì‹¬ ë‹¨ì–´ 1ê°œ ì„ íƒ
3. ë¬¸ì¥ 3ì„ ì½ê³  â†’ í•µì‹¬ ë‹¨ì–´ 1ê°œ ì„ íƒ
4. ... (ëª¨ë“  ${validSentences.length}ê°œ ë¬¸ì¥ì— ëŒ€í•´ ë°˜ë³µ)

**ë‹¨ì–´ ì„ íƒ ê¸°ì¤€:**
- ë¬¸ì¥ì˜ í•µì‹¬ ì˜ë¯¸ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë‹¨ì–´ (ëª…ì‚¬, ë™ì‚¬, í˜•ìš©ì‚¬)
- ê´€ì‚¬(a, an, the), ì „ì¹˜ì‚¬(in, on, at), ì ‘ì†ì‚¬(and, or, but)ëŠ” í”¼í•˜ì„¸ìš”
- ê° ë¬¸ì¥ì—ì„œ ì •í™•íˆ 1ê°œì”©ë§Œ ì„ íƒí•˜ì„¸ìš”

**ì¶œë ¥ í˜•ì‹ (JSONë§Œ):**
{
  "blankedText": "ë¹ˆì¹¸ì´ í¬í•¨ëœ ì „ì²´ ë³¸ë¬¸",
  "correctAnswers": ["ë‹¨ì–´1", "ë‹¨ì–´2", "ë‹¨ì–´3", ...]
}

**ì¤‘ìš”:**
- ì •í™•íˆ ${validSentences.length}ê°œ ë‹¨ì–´ë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤
- ëª¨ë“  ë¬¸ì¥ì—ì„œ 1ê°œì”© ì„ íƒí•˜ì„¸ìš” (ê±´ë„ˆë›°ì§€ ë§ˆì„¸ìš”)
- JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•˜ì„¸ìš”

ì…ë ¥ëœ ì˜ì–´ ë³¸ë¬¸:
${passage}`;
  
  try {
    const request = {
      model: 'gpt-4o',
      messages: [
        { 
          role: 'system', 
          content: `You are an expert English teacher creating blank-fill problems.

CRITICAL RULES:
1. You will receive ${validSentences.length} sentences
2. Select exactly ONE word from each sentence
3. Process ALL ${validSentences.length} sentences - no skipping
4. Return exactly ${validSentences.length} words total

PROCESSING METHOD:
- Read each sentence carefully
- Select the most important word (noun, verb, or adjective)
- Avoid articles (a, an, the), prepositions (in, on, at), conjunctions (and, or, but)
- Each sentence must contribute exactly 1 word

OUTPUT FORMAT:
Return JSON only:
{
  "blankedText": "text with (_______________) for selected words",
  "correctAnswers": ["word1", "word2", ...]
}

Remember: ${validSentences.length} sentences = exactly ${validSentences.length} words!` 
        },
        { role: 'user', content: prompt }
      ],
      max_tokens: 2000,
      temperature: 0.01
    };

    const data = await openAIProxyService.callOpenAI(request);
    console.log('AI ì‘ë‹µ ì „ì²´:', data);
    console.log('AI ì‘ë‹µ ë‚´ìš©:', data.choices[0].message.content);
    
    const jsonMatch = data.choices[0].message.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) throw new Error('AI ì‘ë‹µì—ì„œ JSON í˜•ì‹ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    
    console.log('ì¶”ì¶œëœ JSON:', jsonMatch[0]);
    
    let result: any;
    try {
      result = JSON.parse(jsonMatch[0]);
      console.log('íŒŒì‹±ëœ ê²°ê³¼:', result);
    } catch {
      throw new Error('AI ì‘ë‹µì˜ JSON í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.');
    }
    
    // í•„ìˆ˜ í•„ë“œ ê²€ì¦
    if (!result.blankedText || !result.correctAnswers || !Array.isArray(result.correctAnswers)) {
      throw new Error('AI ì‘ë‹µì— í•„ìˆ˜ í•„ë“œê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }
    
    // ë¬¸ì¥ ìˆ˜ì™€ ì„ íƒëœ ë‹¨ì–´ ìˆ˜ ì¼ì¹˜ ê²€ì¦
    const selectedWordsCount = result.correctAnswers.length;
    
    console.log('ë¬¸ì¥ ìˆ˜ ê²€ì¦:', {
      validSentencesCount: validSentences.length,
      selectedWordsCount: selectedWordsCount,
      validSentences: validSentences.map(s => s.substring(0, 50) + '...')
    });
    
    // 1ë‹¨ê³„: ê°œìˆ˜ ê²€ì¦ (ê°œì„ ëœ ë²„ì „)
    console.log('ğŸ”¢ 1ë‹¨ê³„: ê°œìˆ˜ ê²€ì¦');
    console.log('ë¬¸ì¥ë³„ ìƒì„¸ ì •ë³´:', validSentences.map((sentence, index) => ({
      ë¬¸ì¥ë²ˆí˜¸: index + 1,
      ë¬¸ì¥ë‚´ìš©: sentence.substring(0, 80) + (sentence.length > 80 ? '...' : ''),
      ë‹¨ì–´ìˆ˜: countWordsInSentence(sentence)
    })));
    
    if (validSentences.length !== selectedWordsCount) {
      console.error('âŒ ê°œìˆ˜ ë¶ˆì¼ì¹˜ ìƒì„¸:', {
        ìœ íš¨ë¬¸ì¥ìˆ˜: validSentences.length,
        ì„ íƒëœë‹¨ì–´ìˆ˜: selectedWordsCount,
        ì°¨ì´: validSentences.length - selectedWordsCount,
        ë¹„ìœ¨: `${selectedWordsCount}/${validSentences.length} (${Math.round(selectedWordsCount/validSentences.length*100)}%)`,
        ì„ íƒëœë‹¨ì–´ë“¤: result.correctAnswers,
        ë¬¸ì¥ëª©ë¡: validSentences.map((s, i) => `${i+1}. ${s.substring(0, 50)}...`)
      });
      
      // ì¬ì‹œë„ ë¡œì§ (ìµœëŒ€ 3íšŒë¡œ ì¦ê°€)
      if (retryCount < 3) {
        console.log(`ğŸ”„ ì¬ì‹œë„ ${retryCount + 1}/3 - ë¬¸ì¥ë³„ ë‹¨ì–´ ì„ íƒ ê°•í™”ë¡œ ì¬ì‹œë„`);
        
        // ì¬ì‹œë„ ì‹œ ë” ê°„ë‹¨í•œ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©
        const retryPrompt = `ë‹¤ìŒ ${validSentences.length}ê°œ ë¬¸ì¥ì—ì„œ ê° ë¬¸ì¥ë§ˆë‹¤ í•µì‹¬ ë‹¨ì–´ 1ê°œì”©ì„ ì„ íƒí•˜ì„¸ìš”.

ë¬¸ì¥ ëª©ë¡:
${validSentences.map((sentence, index) => `${index + 1}. "${sentence}"`).join('\n')}

ê·œì¹™:
- ê° ë¬¸ì¥ì—ì„œ ì •í™•íˆ 1ê°œì”© ì„ íƒ
- ì´ ${validSentences.length}ê°œ ë‹¨ì–´ ì„ íƒ
- JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µ

ì¶œë ¥ í˜•ì‹:
{
  "blankedText": "ë¹ˆì¹¸ì´ í¬í•¨ëœ ì „ì²´ ë³¸ë¬¸",
  "correctAnswers": ["ë‹¨ì–´1", "ë‹¨ì–´2", ...]
}

ì…ë ¥ëœ ì˜ì–´ ë³¸ë¬¸:
${passage}`;

        // ì¬ì‹œë„ìš© ê°„ë‹¨í•œ í”„ë¡¬í”„íŠ¸ë¡œ ë‹¤ì‹œ ì‹œë„
        const retryRequest = {
          model: 'gpt-4o',
          messages: [
            { 
              role: 'system', 
              content: `You are an expert English teacher. Select exactly ONE word from each sentence. Process all ${validSentences.length} sentences. Return JSON format only.`
            },
            { role: 'user', content: retryPrompt }
          ],
          max_tokens: 2000,
          temperature: 0.01
        };

        const retryData = await openAIProxyService.callOpenAI(retryRequest);
        const retryJsonMatch = retryData.choices[0].message.content.match(/\{[\s\S]*\}/);
        if (retryJsonMatch) {
          try {
            const retryResult = JSON.parse(retryJsonMatch[0]);
            if (retryResult.blankedText && retryResult.correctAnswers && 
                Array.isArray(retryResult.correctAnswers) && 
                retryResult.correctAnswers.length === validSentences.length) {
              console.log('âœ… ì¬ì‹œë„ ì„±ê³µ - ëª¨ë“  ë¬¸ì¥ì—ì„œ ë‹¨ì–´ ì„ íƒ ì™„ë£Œ');
              result = retryResult;
            } else {
              throw new Error('ì¬ì‹œë„ ê²°ê³¼ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            }
          } catch (retryError) {
            console.error('ì¬ì‹œë„ JSON íŒŒì‹± ì˜¤ë¥˜:', retryError);
            return generateBlankFillQuizWithAI(passage, retryCount + 1);
          }
        } else {
          return generateBlankFillQuizWithAI(passage, retryCount + 1);
        }
        } else {
          return generateBlankFillQuizWithAI(passage, retryCount + 1);
        }
      } else {
        throw new Error(`âŒ ì‹¬ê°í•œ ì˜¤ë¥˜: AIê°€ ${validSentences.length}ê°œ ë¬¸ì¥ ì¤‘ ${selectedWordsCount}ê°œë§Œ ì²˜ë¦¬í–ˆìŠµë‹ˆë‹¤. 
        
        ë¬¸ì¥ ëª©ë¡:
        ${validSentences.map((s, i) => `${i+1}. ${s}`).join('\n')}
        
        ì„ íƒëœ ë‹¨ì–´: ${result.correctAnswers.join(', ')}
        
        ëª¨ë“  ë¬¸ì¥ì—ì„œ ë‹¨ì–´ë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.`);
      }
    }
  
    // 2ë‹¨ê³„: ë¬¸ì¥ë³„ ë‹¨ì–´ ë§¤í•‘ ê²€ì¦ (ê°œì„ ëœ ë²„ì „)
    console.log('ğŸ” 2ë‹¨ê³„: ë¬¸ì¥ë³„ ë‹¨ì–´ ë§¤í•‘ ê²€ì¦');
    const selectedWords = result.correctAnswers;
    
    // ê° ë¬¸ì¥ì— ëŒ€í•´ ì„ íƒëœ ë‹¨ì–´ ì¤‘ í•˜ë‚˜ê°€ ìˆëŠ”ì§€ í™•ì¸ (ë” ìœ ì—°í•œ ê²€ìƒ‰)
    const sentenceWordMapping: { 
       sentenceIndex: number, 
       sentence: string, 
       matchedWord?: string,
       allWordsInSentence: string[],
       searchResults: { word: string, found: boolean }[]
     }[] = [];
     
     for (let i = 0; i < validSentences.length; i++) {
       const sentence = validSentences[i];
       const sentenceWords = sentence.toLowerCase().split(/\s+/).filter(w => w.length > 0);
       const searchResults: { word: string, found: boolean }[] = [];
       let matchedWord: string | undefined;
       
       // ì„ íƒëœ ë‹¨ì–´ë“¤ì„ ì´ ë¬¸ì¥ì—ì„œ ê²€ìƒ‰ (ë” ìœ ì—°í•œ ë§¤ì¹­)
       for (const selectedWord of selectedWords) {
         const selectedWordLower = selectedWord.toLowerCase().trim();
         const found = sentenceWords.some(word => {
           const wordClean = word.replace(/[.,!?;:]/g, '').toLowerCase();
           return wordClean === selectedWordLower || 
                  wordClean.includes(selectedWordLower) || 
                  selectedWordLower.includes(wordClean);
         });
         searchResults.push({ word: selectedWord, found });
         
         if (found && !matchedWord) {
           matchedWord = selectedWord;
         }
       }
       
       sentenceWordMapping.push({
         sentenceIndex: i + 1,
         sentence: sentence.substring(0, 100) + (sentence.length > 100 ? '...' : ''),
         matchedWord,
         allWordsInSentence: sentenceWords,
         searchResults
       });
       
       console.log(`  ë¬¸ì¥ ${i + 1}: ${matchedWord ? 'âœ…' : 'âŒ'} ${matchedWord ? `"${matchedWord}"` : 'ë‹¨ì–´ ì—†ìŒ'}`);
       if (!matchedWord) {
         console.log(`    ë¬¸ì¥ì˜ ë‹¨ì–´ë“¤: [${sentenceWords.slice(0, 10).join(', ')}${sentenceWords.length > 10 ? '...' : ''}]`);
         console.log(`    ì„ íƒëœ ë‹¨ì–´ë“¤: [${selectedWords.join(', ')}]`);
       }
     }
     
     const missingSentences = sentenceWordMapping.filter(item => !item.matchedWord);
     
     if (missingSentences.length > 0) {
       console.error('âŒ ë¬¸ì¥ë³„ ë‹¨ì–´ ë§¤í•‘ ì‹¤íŒ¨ ìƒì„¸:');
       missingSentences.forEach(item => {
         console.error(`  ë¬¸ì¥ ${item.sentenceIndex}: "${item.sentence}"`);
         console.error(`    ë¬¸ì¥ì˜ ë‹¨ì–´ë“¤: [${item.allWordsInSentence.join(', ')}]`);
         console.error(`    ê²€ìƒ‰ ê²°ê³¼:`, item.searchResults);
       });
       
       // ì¬ì‹œë„ ë¡œì§ (ìµœëŒ€ 3íšŒ)
       if (retryCount < 3) {
         console.log(`ğŸ”„ ì¬ì‹œë„ ${retryCount + 1}/3 - ë¬¸ì¥ë³„ ë‹¨ì–´ ë§¤í•‘ ì‹¤íŒ¨ë¡œ ì¬ì‹œë„`);
         return generateBlankFillQuizWithAI(passage, retryCount + 1);
       }
       
       const missingDetails = missingSentences.map(item => 
         `ë¬¸ì¥ ${item.sentenceIndex}: "${item.sentence.substring(0, 80)}..."`
       ).join('\n');
       
       throw new Error(`AIê°€ ${missingSentences.length}ê°œ ë¬¸ì¥ì—ì„œ ë‹¨ì–´ë¥¼ ì„ íƒí•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ëª¨ë“  ë¬¸ì¥ì—ì„œ ë‹¨ì–´ë¥¼ ì„ íƒí•´ì•¼ í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.\n\nëˆ„ë½ëœ ë¬¸ì¥ë“¤:\n${missingDetails}`);
     }
    
    console.log('âœ… ëª¨ë“  ë¬¸ì¥ì—ì„œ ë‹¨ì–´ ì„ íƒ ì™„ë£Œ - ê²€ì¦ í†µê³¼');
    console.log('ğŸ” === AI ì‘ë‹µ ìƒì„¸ ë¶„ì„ ì™„ë£Œ ===');
    
    // ê° ì •ë‹µ ë‹¨ì–´ê°€ ë³¸ë¬¸ì— ì‹¤ì œë¡œ ì¡´ì¬í•˜ëŠ”ì§€ ê²€ì¦ (ëŒ€ì†Œë¬¸ì êµ¬ë¶„ ì—†ì´)
    const correctAnswers = result.correctAnswers;
    const passageLower = passage.toLowerCase();
    
    console.log('ê²€ì¦ ì •ë³´:', {
      originalPassage: passage.substring(0, 100) + '...',
      correctAnswers: correctAnswers,
      passageLower: passageLower.substring(0, 100) + '...'
    });
    
    // ë³¸ë¬¸ì—ì„œ ì´ë¯¸ ()ë¡œ ë¬¶ì¸ ë‹¨ì–´ë‚˜ êµ¬ ì¶”ì¶œ (ì œì™¸í•  ë‹¨ì–´ë“¤)
    const excludedWords: string[] = [];
    const bracketRegex = /\(([^)]+)\)/g;
    let match;
    while ((match = bracketRegex.exec(passage)) !== null) {
      excludedWords.push(match[1].trim());
    }
    
    for (let i = 0; i < correctAnswers.length; i++) {
      const answerLower = correctAnswers[i].toLowerCase();
      
      if (!passageLower.includes(answerLower)) {
        // ì •í™•í•œ ë‹¨ì–´ ê²½ê³„ë¡œ ë‹¤ì‹œ ê²€ì¦
        const wordBoundaryRegex = new RegExp(`\\b${answerLower}\\b`);
        if (!wordBoundaryRegex.test(passageLower)) {
          console.error('ì •ë‹µ ë‹¨ì–´ ê²€ì¦ ì‹¤íŒ¨:', {
            correctAnswer: correctAnswers[i],
            passage: passage.substring(0, 200),
            excludedWords
          });
          throw new Error(`ì •ë‹µ ë‹¨ì–´ "${correctAnswers[i]}"ê°€ ë³¸ë¬¸ì— ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. AI ì‘ë‹µ ì˜¤ë¥˜ì…ë‹ˆë‹¤.`);
        }
      }
    }

    // ì£¼ì œì–´ ì„ ì • í’ˆì§ˆ ê²€ì¦
    console.log('ì£¼ì œì–´ ì„ ì • í’ˆì§ˆ ê²€ì¦:', {
      correctAnswers: correctAnswers,
      passage: passage.substring(0, 200)
    });
    
    // ë¹ˆì¹¸ ë³¸ë¬¸ì´ ì›ë³¸ ë³¸ë¬¸ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ ê²€ì¦
    let blankRestore = result.blankedText;
    for (let i = 0; i < correctAnswers.length; i++) {
      blankRestore = blankRestore.replace(/\(_{15}\)/, correctAnswers[i]);
    }
    
    // ê³µë°±ê³¼ êµ¬ë‘ì ì„ ì •ê·œí™”í•˜ì—¬ ë¹„êµ
    const normalizeText = (text: string) => {
      return text
        .trim()
        .replace(/\s+/g, ' ')  // ì—¬ëŸ¬ ê³µë°±ì„ í•˜ë‚˜ë¡œ
        .replace(/[.,!?;:]/g, '')  // êµ¬ë‘ì  ì œê±°
        .toLowerCase();
    };
    
    const normalizedOriginal = normalizeText(passage);
    const normalizedRestored = normalizeText(blankRestore);
    
    console.log('ë¹ˆì¹¸ ë³¸ë¬¸ ê²€ì¦:', {
      original: normalizedOriginal.substring(0, 100),
      restored: normalizedRestored.substring(0, 100),
      blankedText: result.blankedText.substring(0, 100),
      match: normalizedRestored === normalizedOriginal
    });
    
    if (normalizedRestored !== normalizedOriginal) {
      console.warn('ë¹ˆì¹¸ ë³¸ë¬¸ ê²€ì¦ ì‹¤íŒ¨ - ìƒì„¸ ì •ë³´:', {
        original: passage.substring(0, 300),
        blankedText: result.blankedText.substring(0, 300),
        restored: blankRestore.substring(0, 300),
        correctAnswers: correctAnswers
      });
      
      // ì •ë‹µ ë‹¨ì–´ê°€ ë³¸ë¬¸ì— ì¡´ì¬í•˜ê³ , ë¹ˆì¹¸ì´ ì ì ˆíˆ ë°°ì¹˜ë˜ì–´ ìˆìœ¼ë©´ í†µê³¼
      const allAnswersExist = correctAnswers.every((answer: string) => 
        passageLower.includes(answer.toLowerCase())
      );
      if (allAnswersExist && result.blankedText.includes('(_______________)')) {
        console.log('ì •ë‹µ ë‹¨ì–´ê°€ ë³¸ë¬¸ì— ì¡´ì¬í•˜ê³  ë¹ˆì¹¸ì´ ì ì ˆíˆ ë°°ì¹˜ë˜ì–´ ìˆì–´ í†µê³¼í•©ë‹ˆë‹¤.');
      } else {
        throw new Error('ë¹ˆì¹¸ ë³¸ë¬¸ì´ ì›ë³¸ ë³¸ë¬¸ê³¼ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. AI ì‘ë‹µ ì˜¤ë¥˜ì…ë‹ˆë‹¤.');
      }
    }
    
    // ë²ˆì—­ì€ ë³„ë„ í•¨ìˆ˜ë¡œ ì²˜ë¦¬
    console.log('ë²ˆì—­ ì‹œì‘...');
    const translation = await translateToKorean(passage);
    result.translation = translation;
    
    console.log('ìµœì¢… ê²€ì¦ ì „ ê²°ê³¼:', {
      blankedText: result.blankedText,
      correctAnswers: result.correctAnswers,
      translation: result.translation
    });
    
    if (!result.blankedText || !result.correctAnswers || !result.translation) {
      throw new Error('AI ì‘ë‹µì— í•„ìˆ˜ í•„ë“œê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.');
    }
    
    console.log('AI ì‘ë‹µ ê²€ì¦ ì™„ë£Œ, ë°˜í™˜í•  ê²°ê³¼:', result);
    return result;
    
  } catch (error) {
    console.error('AI ë¬¸ì œ ìƒì„± ì˜¤ë¥˜:', error);
    throw error;
  }
};
